#=============================================================================
# PROJECT OVERVIEW: Spatiotemporal Modeling & Forecasting of Scotland's Climate
#=============================================================================
# 
# 1. RESEARCH OBJECTIVE:
# To model and forecast the spatiotemporal dynamics of monthly temperature 
# changes in Scotland, accounting for seasonal patterns, geographic factors, 
# and temporal climate inertia.
#
# 2. DATA PREPARATION:
# - Spatial Scope: Scotland region only.
# - Transformation: Applied first-order differencing (Temp_Diff) to the 
#   absolute temperature data to achieve stationarity and remove long-term trends.
# 
# 3. METHODOLOGY & TRAIN/TEST SPLIT:
# - Training Set: 100 years of historical data (1901-2000) for model fitting.
# - Test Set: 12 years of out-of-sample data (2001-2012) for forecasting.
#
# 4. EVALUATION & OUTPUTS:
# - Calculates In-Sample relative fit (DIC) and Out-of-Sample predictive 
#   power (Pseudo R-squared).
# - Generates Goodness-of-Fit scatter plots and reconstructs absolute 
#   temperature forecasting time-series for the test period.
#
#=============================================================================
# MODEL SPECIFICATION: Bayesian Spatiotemporal Model with AR(1) Errors
#=============================================================================
#
# 1. CORE MATHEMATICAL EQUATIONS
#
# Observation Equation (Differenced Temperature):
# Delta Y_{i,t} = mu_{i,t} + epsilon_{i,t}
#
# Deterministic Mean Equation:
# mu_{i,t} = beta_0 + MonthEffect_{m(t)} + beta_2 * Lat_{i} + beta_3 * Lon_{i} + alpha_i
#
# Error Equation (AR(1)) & Distribution Assumptions:
# epsilon_{i,t} = rho * epsilon_{i,t-1} + u_{i,t}
# u_{i,t} ~ N(0, sigma^2_{obs})
# alpha_i ~ N(0, sigma^2_{alpha})
#
#-----------------------------------------------------------------------------
# 2. PARAMETER DEFINITIONS & SCIENTIFIC INTERPRETATIONS
#-----------------------------------------------------------------------------
# Delta Y_{i,t} : The month-to-month temperature difference at location i, time t.
# mu_{i,t}      : Baseline expected temperature change.
# beta_0        : Global intercept (baseline temperature change).
# MonthEffect   : Seasonal fixed effect. Captures expected temperature shifts 
#                 between consecutive months (e.g., Nov to Dec cooling).
# beta_2, beta_3: Fixed effects for Latitude and Longitude, capturing the 
#                 spatial climate gradients across Scotland.
# alpha_i       : Spatial random effect. Absorbs unobserved local geographical 
#                 heterogeneity (e.g., elevation, coastal proximity).
# epsilon_{i,t} : Total residual error.
# rho (Rho)     : AR(1) Autoregressive coefficient. Captures the "mean-reverting" 
#                 or "persistence" nature of temperature anomalies.
# u_{i,t}       : Pure white noise (random weather shocks).
#=============================================================================

# load the `ncdf4` and the `CFtime` packages
install.packages(c("ncdf4", "CFtime"))
library(ncdf4)
library(CFtime)

library(lattice)
library(RColorBrewer)

# set path and filename
ncpath <- "C:/Users/Lenovo/Desktop"
ncname  <- "temp_data_SRS"
ncfname <- file.path(ncpath, paste0(ncname, ".nc"))
dname   <- "tmp"
ncin <- nc_open(ncfname)
print(ncin)

#=============================================================================

# load("Scotland_Climate_JAGS_Results.RData") # you do not need to run block 2,3 after loading

#=============================================================================
# BLOCK 1: Package Loading and Data Preparation (Differencing & Splitting)
#=============================================================================
# Install packages if you haven't already:
install.packages(c("dplyr", "rjags", "coda", "ggplot2"))

library(dplyr)
library(rjags)
library(coda)
library(ggplot2)

# Assuming 'scotland_clean' is already loaded and contains: lon, lat, time, temp
# 1. Basic cleaning and first-order differencing
df_diff <- scotland_clean %>%
  # Create a unique Location ID for each longitude-latitude pair
  mutate(Loc_ID = as.numeric(factor(paste(lon, lat, sep="_")))) %>%
  arrange(Loc_ID, time) %>%
  group_by(Loc_ID) %>%
  mutate(
    # Calculate month-to-month temperature difference
    Temp_Diff = temp - lag(temp),
    # Create a month index (1 to 12)
    Month_Index = rep(1:12, length.out = n()),
    # Create a continuous time step
    Time_Step = row_number(),
    # Approximate the year (Assuming data starts in Jan 1901)
    Year_approx = 1901 + (Time_Step - 1) / 12 
  ) %>%
  # Remove the first NA row generated by the lag() function
  filter(!is.na(Temp_Diff)) %>% 
  ungroup()

# 2. Split into Training Set (100 years) and Test Set (12 years)
# Training Set: 1901 to 2000
df_train <- df_diff %>% filter(Year_approx < 2001)
# Test Set: 2001 to 2012
df_test <- df_diff %>% filter(Year_approx >= 2001)

# 3. Extract dimensions and static variables for JAGS (using Training Set only)
locations <- df_train %>% distinct(Loc_ID, lon, lat) %>% arrange(Loc_ID)
N_locs <- nrow(locations)
N_time_train <- length(unique(df_train$time))

Lat_vec <- locations$lat
Lon_vec <- locations$lon
Month_vec_train <- df_train %>% filter(Loc_ID == 1) %>% pull(Month_Index)

# Build the data matrix for the Training Set
Y_train_matrix <- matrix(df_train$Temp_Diff, nrow = N_locs, ncol = N_time_train, byrow = TRUE)

# Package all necessary data into a list for JAGS
jags_data <- list(
  Y_diff = Y_train_matrix,
  Lat = Lat_vec,
  Lon = Lon_vec,
  Month = Month_vec_train,
  N_locs = N_locs,
  N_time = N_time_train
)

#=============================================================================
# BLOCK 2: JAGS Model Definition and MCMC Sampling (Training)
#=============================================================================
# Define the Bayesian Spatiotemporal AR(1) Model
model_string <- "
model {
  # 1. Likelihood and AR(1) error structure
  for (i in 1:N_locs) {
    # Initial state (t = 1)
    Y_diff[i, 1] ~ dnorm(mu[i, 1], tau_obs)
    mu[i, 1] <- beta0 + MonthEffect[Month[1]] + beta2 * Lat[i] + beta3 * Lon[i] + alpha[i]
    epsilon[i, 1] <- Y_diff[i, 1] - mu[i, 1]

    # Time series transition (t > 1)
    for (t in 2:N_time) {
      Y_diff[i, t] ~ dnorm(mu[i, t] + rho * epsilon[i, t-1], tau_obs)
      mu[i, t] <- beta0 + MonthEffect[Month[t]] + beta2 * Lat[i] + beta3 * Lon[i] + alpha[i]
      epsilon[i, t] <- Y_diff[i, t] - mu[i, t]
    }
    
    # Spatial random effects
    alpha[i] ~ dnorm(0, tau_alpha)
  }

  # 2. Priors
  beta0 ~ dnorm(0, 0.001)
  beta2 ~ dnorm(0, 0.001) # Latitude coefficient
  beta3 ~ dnorm(0, 0.001) # Longitude coefficient

  # Corner constraint for Seasonality (Set Jan = 0)
  MonthEffect[1] <- 0
  for (m in 2:12) { 
    MonthEffect[m] ~ dnorm(0, 0.001) 
  }

  # Precision parameters for error and random effects
  tau_obs ~ dgamma(0.01, 0.01)
  tau_alpha ~ dgamma(0.01, 0.01)
  
  # AR(1) coefficient bounded for stationarity
  rho ~ dunif(-1, 1)
}
"
# Write the model string to a temporary text file
writeLines(model_string, con = "spatiotemporal_model_train.jags")

# Initialize and train the model (Only using the first 100 years of data)
jags_model <- jags.model(
  file = "spatiotemporal_model_train.jags", 
  data = jags_data, 
  n.chains = 3, 
  n.adapt = 1000  # Adaptation phase
)

# Burn-in phase (Let the Markov chains stabilize)
update(jags_model, n.iter = 2000)

# Calculate and print the DIC (Relative Goodness-of-Fit) for the Training Set
cat("\n--- Calculating DIC ---\n")
dic_value <- dic.samples(jags_model, n.iter = 2000)
print(dic_value)

# Extract posterior samples for the parameters we care about
mcmc_samples <- coda.samples(
  model = jags_model,
  variable.names = c("beta0", "beta2", "beta3", "MonthEffect", "rho", "alpha"),
  n.iter = 2000
)

#=============================================================================
# BLOCK 3: Save Results (Run this once to save your progress!)
#=============================================================================
# Save the entire R environment (data, models, MCMC samples) to your hard drive.
# This ensures you don't lose the results if R crashes or restarts.
save.image(file = "Scotland_Climate_JAGS_Results.RData")

cat("\n--- All results successfully saved to 'Scotland_Climate_JAGS_Results.RData' ---\n")

# NOTE: Next time you open RStudio, you can skip BLOCK 2 and just run:
# load("Scotland_Climate_JAGS_Results.RData")
# to instantly restore all your trained models and data!

#=============================================================================
# BLOCK 4: Full Dataset Prediction & Pseudo R-Squared Calculation
#=============================================================================
# Extract posterior means from the MCMC samples
post_means <- summary(mcmc_samples)$statistics[, "Mean"]

# Assign means to corresponding R variables
beta0_hat <- post_means["beta0"]
beta2_hat <- post_means["beta2"]
beta3_hat <- post_means["beta3"]
rho_hat <- post_means["rho"]

# Extract the 12 month effects (adding 0 for January)
month_eff_hat <- c(0, sapply(2:12, function(m) post_means[paste0("MonthEffect[", m, "]")]))

# Extract spatial random effects for all locations
alpha_hat <- sapply(1:N_locs, function(i) post_means[paste0("alpha[", i, "]")])

# Calculate fitted values for ALL 112 years (using parameters learned from the first 100 years)
df_pred_all <- df_diff %>%
  mutate(
    # Base expected value without AR(1) inertia
    mu_hat = beta0_hat + month_eff_hat[Month_Index] + beta2_hat * lat + beta3_hat * lon + alpha_hat[Loc_ID],
    # Calculate current month's residual
    epsilon_hat = Temp_Diff - mu_hat
  ) %>%
  group_by(Loc_ID) %>%
  mutate(
    # Y_fitted is the one-step-ahead prediction (adding last month's residual effect)
    Y_fitted = mu_hat + rho_hat * lag(epsilon_hat, default = 0),
    # Reconstruct the absolute predicted temperature
    Predicted_Absolute_Temp = lag(temp) + Y_fitted
  ) %>%
  ungroup()

# Separate the results back into Training and Test sets
train_results <- df_pred_all %>% filter(Year_approx < 2001)
test_results <- df_pred_all %>% filter(Year_approx >= 2001)

# Calculate Bayesian Pseudo R-squared (Absolute Goodness-of-Fit)
r2_train <- cor(train_results$Temp_Diff, train_results$Y_fitted, use = "complete.obs")^2
r2_test <- cor(test_results$Temp_Diff, test_results$Y_fitted, use = "complete.obs")^2

cat("\n--- Absolute Goodness-of-Fit (Pseudo R-squared) ---\n")
cat("Training Set (1901-2000) R-squared:", round(r2_train, 4), "\n")
cat("Test Set     (2001-2012) R-squared:", round(r2_test, 4), "\n")

#=============================================================================
# BLOCK 5: Visualization (Scatter Plots & Time Series)
#=============================================================================
# Plot 1: Training Set Scatter Plot (Sampled to avoid overplotting/lag)
p1 <- ggplot(train_results %>% sample_n(min(5000, nrow(.))), aes(x = Y_fitted, y = Temp_Diff)) +
  geom_point(alpha = 0.3, color = "dodgerblue") +
  geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed", linewidth = 1) +
  labs(
    title = "TRAIN SET: Actual vs Predicted (100 Years)", 
    subtitle = paste("Pseudo R-squared =", round(r2_train, 4)), 
    x = "Predicted Temp Difference", 
    y = "Actual Temp Difference"
  ) +
  theme_minimal()

# Plot 2: Test Set Scatter Plot
p2 <- ggplot(test_results %>% sample_n(min(5000, nrow(.))), aes(x = Y_fitted, y = Temp_Diff)) +
  geom_point(alpha = 0.4, color = "darkorange") +
  geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed", linewidth = 1) +
  labs(
    title = "TEST SET: Actual vs Predicted (12 Years)", 
    subtitle = paste("Pseudo R-squared =", round(r2_test, 4)), 
    x = "Predicted Temp Difference", 
    y = "Actual Temp Difference"
  ) +
  theme_minimal()

# Print the scatter plots
print(p1)
print(p2)

# Extract a single location from the Test Set for the time series plot
test_ts_single_loc <- test_results %>% filter(Loc_ID == 1)

# Plot 3: Test Set 12-Year Absolute Temperature Time Series Plot
p3 <- ggplot(test_ts_single_loc, aes(x = Year_approx)) +
  # Actual Temperature (Black solid line)
  geom_line(aes(y = temp, color = "Actual Temperature"), linewidth = 0.7, alpha = 0.8) +
  # Predicted Temperature (Red dashed line)
  geom_line(aes(y = Predicted_Absolute_Temp, color = "Predicted Temperature"), linewidth = 0.7, alpha = 0.8, linetype = "twodash") +
  
  scale_color_manual(values = c("Actual Temperature" = "black", "Predicted Temperature" = "red")) +
  scale_x_continuous(breaks = seq(2001, 2012, by = 1)) +
  
  labs(
    title = "TEST SET Forecasting: Absolute Temperature (2001-2012)", 
    subtitle = "One-Step-Ahead Prediction for a Single Location in Scotland", 
    x = "Year", 
    y = "Temperature (Â°C)", 
    color = "Legend"
  ) +
  theme_minimal() + 
  theme(legend.position = "bottom")

# Print the time series plot
print(p3)
#=============================================================================